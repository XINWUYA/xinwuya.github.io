<!DOCTYPE html>
<!--[if lt IE 7 ]><html class="ie ie6" lang="en"> <![endif]-->
<!--[if IE 7 ]><html class="ie ie7" lang="en"> <![endif]-->
<!--[if IE 8 ]><html class="ie ie8" lang="en"> <![endif]-->
<!--[if (gte IE 9)|!(IE)]><!--><html lang="en"> <!--<![endif]-->
<head>

    <!-- Basic Page Needs
  ================================================== -->
	<meta charset="utf-8">
	<title>XINWUYA</title>
	<meta name="description" content="Free Responsive Html5 Css3 Templates | zerotheme.com">
	<meta name="author" content="www.zerotheme.com">
	
    <!-- Mobile Specific Metas
  ================================================== -->
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <!-- CSS
  ================================================== -->
  	<link rel="stylesheet" href="../css/zerogrid.css">
	<link rel="stylesheet" href="../css/style_blog.css">
	<link rel="stylesheet" href="../css/component.css">
	<link rel="stylesheet" href="../css/responsive.css">
	<!--[if lt IE 8]>
       <div style=' clear: both; text-align:center; position: relative;'>
         <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
           <img src="http://storage.ie6countdown.com/assets/100/images/banners/warning_bar_0000_us.jpg" border="0" height="42" width="820" alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today." />
        </a>
      </div>
    <![endif]-->
    <!--[if lt IE 9]>
		<script src="js/html5.js"></script>
		<script src="js/css3-mediaqueries.js"></script>
	<![endif]-->
	
	<link href='../images/favicon.ico' rel='icon' type='../image/x-icon'/>
    
</head>
<body>
<div class="wrap-body">

<!--------------Header---------------->
<header>
	<div class="top-header">
		<div class="wrap-top zerogrid">
			<div class="row">
				<div class="top-social">
					<a href="https://github.com/XINWUYA/xinwuya.github.io"><img src="../images/github.png" title="github"/></a>
				</div>
				<div class="top-search"><form method="get" action="/search" id="search">
				  <input name="q" type="text" size="40" placeholder="Search..." />
				</form></div>
			</div>
		</div>
	</div>
	<div class="wrap-header zerogrid">
		<div class="row">
			<div class="col-1-3">
				<div id="logo"><a href="../index.html"><img src="../images/logo.png"/></a></div>	
			</div>
			<div class="col-2-3">
				<nav>
					<a class="toggleMenu" href="#">Menu</a>
					<ul class="menu">
						<li><a href="../index.html">Home</a></li>
						<li><a href="../c_plus_plus.html">Back</a></li>
						<li><a href="../single.html">About</a></li>
						<li><a href="../contact.html">Contact Us</a></li>
					</ul>
				</nav>
			</div>
			
		</div>
	</div>
</header>

    

<!--------------Content---------------->
<section class="container page-single">
	<div class="wrap-container zerogrid">
		<div class="col-3-4">
			<div id="main-content" class="wrap-col">
				<article>
					<img src="./images/new_and_malloc.jpg" />
					<div class="art-header">
						<h2>new和malloc的区别</h2>
						<div class="info">By xinwuya on Feb 27, 2019</div>
						<div class="line"></div>
					</div>
					<div class="art-content">
    					<div id="overriew">
							<h3>概述：</h3>
							<table>
							<thead>
							<tr>
							<th style="text-align:center">序号</th>
							<th style="text-align:center">不同点</th>
							<th style="text-align:center">new/delete</th>
							<th style="text-align:center">malloc/free</th>
							</tr>
							</thead>
							<tbody>
							<tr>
							<td style="text-align:center">1</td>
							<td style="text-align:center">申请内存的位置</td>
							<td style="text-align:center">自由存储区</td>
							<td style="text-align:center">堆</td>
							</tr>
							<tr>
							<td style="text-align:center">2</td>
							<td style="text-align:center">内存分配成功时返回值</td>
							<td style="text-align:center">返回对象类型的指针，无需进行类型转换</td>
							<td style="text-align:center">返回的是void *，需要通过强制类型转换将void *转换成我们需要的类型</td>
							</tr>
							<tr>
							<td style="text-align:center">3</td>
							<td style="text-align:center">内存分配失败时返回值</td>
							<td style="text-align:center">抛出bad_malloc异常，不会返回NULL</td>
							<td style="text-align:center">返回NULL</td>
							</tr>
							<tr>
							<td style="text-align:center">4</td>
							<td style="text-align:center">分配内存的大小</td>
							<td style="text-align:center">由编译器根据类型计算得出</td>
							<td style="text-align:center">必须显式指定字节数</td>
							</tr>
							<tr>
							<td style="text-align:center">5</td>
							<td style="text-align:center">调用构造函数/析构函数</td>
							<td style="text-align:center">调用</td>
							<td style="text-align:center">不调用</td>
							</tr>
							<tr>
							<td style="text-align:center">6</td>
							<td style="text-align:center">处理数组</td>
							<td style="text-align:center">有处理数组的new[]/delete[]</td>
							<td style="text-align:center">需要用户计算数组的大小后进行内存分配</td>
							</tr>
							<tr>
							<td style="text-align:center">7</td>
							<td style="text-align:center">相互调用</td>
							<td style="text-align:center">new和delete可以通过malloc/free实现</td>
							<td style="text-align:center">不能调用new</td>
							</tr>
							<tr>
							<td style="text-align:center">8</td>
							<td style="text-align:center">是否允许函数重载</td>
							<td style="text-align:center">允许</td>
							<td style="text-align:center">不允许</td>
							</tr>
							<tr>
							<td style="text-align:center">9</td>
							<td style="text-align:center">能否重新分配内存（内存扩容）</td>
							<td style="text-align:center">无法直观的处理</td>
							<td style="text-align:center">可以使用realloc简单完成</td>
							</tr>
							<tr>
							<td style="text-align:center">10</td>
							<td style="text-align:center">分配内存时内存不足时</td>
							<td style="text-align:center">客户能够指定处理函数或者重新制定分配器</td>
							<td style="text-align:center">无法通过用户代码处理</td>
							</tr>
							</tbody>
							</table>
						</div>
						<div id="text_01">
							<h3>1.申请的内存所在位置</h3>
							<p>new操作符从<strong>自由存储区</strong>上为对象动态分配内存空间，而malloc从<strong>堆</strong>上动态分配内存。</p>
							<p>自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。</p>
							<p>那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。</p>
							<p>特别的，new甚至可以不为对象分配内存！定位new的功能可以办到这一点：</p>
							<p>new (place_address) type
							place_address为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用new操作符时，new操作符调用特殊的operator new，也就是下面这个版本：</p>
							<p>void * operator new (size_t,void *) //不允许重定义这个版本的operator new
							这个operator new不分配任何的内存，它只是简单地返回指针实参，然后右new表达式负责在place_address指定的地址进行对象的初始化工作。</p>
						</div>
						<div id="text_02">
							<h3>2.返回类型安全性</h3>
							<p>new操作符内存分配成功时，返回的是对象类型的指针，<strong>类型严格与对象匹配</strong>，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，<strong>需要通过强制类型转换将void*指针转换成我们需要的类型</strong>。</p>
							<p>类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图方法自己没被授权的内存区域。关于C++的类型安全性可说的又有很多了。</p>
						</div>
						<div id="text_03">
						<h3>3.内存分配失败时的返回值</h3>
							<p>new内存分配失败时，会抛出bad_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。</p>
							<p>在使用C语言时，我们习惯在malloc分配内存后判断分配是否成功：</p>
							<pre><code class="language-c++">int *a  = (int *)malloc ( sizeof (int ));<br/>if(NULL == a)<br/>{<br/><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>...<br/>}<br/>else<br/>{<br/><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>...<br/>}</code></pre>
							<p>从C语言走入C++阵营的新手可能会把这个习惯带入C++：</p>
							<pre><code class="language-c++">int * a = new int();<br/>if(NULL == a)<br/>{<br/><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>...<br/>}<br/>else<br/>{<br/><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>...<br/>}<br/></code></pre>
							<p>实际上这样做一点意义也没有，因为new根本不会返回NULL，而且程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制：</p>
							<pre><code class="language-c++">try<br/>{<br/><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>int *a = new int();<br/>}<br/>catch (bad_alloc)<br/>{<br/><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>...<br/>}</code></pre>
						</div>
						<div id="text_04">
							<h3>4.是否指定内存大小</h3>
							<p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。</p>
						</div>
						<div id="text_05">
						<h3>5.是否调用构造/析构函数</h3>
							<p>使用new操作符来分配对象内存时会经历三个步骤：
							第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。
							第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。
							第三部：对象构造完成后，返回一个指向该对象的指针。</p>
							<p>使用delete操作符来释放对象内存时会经历两个步骤：
							第一步：调用对象的析构函数。
							第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。</p>
							<p>总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。</p>
							<p>如果你不嫌啰嗦可以看下我的例子：</p>
							<pre><code class="language-c++">class A<br/>{<br/>public:<br/><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>A() :a(1), b(1.11){}<br/>private:<br/><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>int a;<br/><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>double b;<br/>};<br/>int main()<br/>{<br/><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>A * ptr = (A*)malloc(sizeof(A));<br/><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>return 0;<br/>}<br/></code></pre>
							<p>在return处设置断点，观看ptr所指内存的内容：</p>
							<p><img src="./images/ptr1.png" alt=""></p>
							<p>可以看出A的默认构造函数并没有被调用，因为数据成员a,b的值并没有得到初始化，这也是上面我为什么说使用malloc/free来处理C++的自定义类型不合适，其实不止自定义类型，标准库中凡是需要构造/析构的类型通通不合适。</p>
							<p>而使用new来分配对象时：</p>
							<pre><code class="language-c++">int main()<br/>{<br/><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>A * ptr = new A;<br/>}<br/></code></pre>
							<p>查看程序生成的汇编代码可以发现，A的默认构造函数被调用了：</p>
							<p><img src="./images/ptr2.png" alt=""></p>
						</div>
						<div id="text_06">
							<h3>6.对数组的处理</h3>
							<p>C++提供了new[]与delete[]来专门处理数组类型:
							<code>A * ptr = new A[10];//分配10个A对象</code>
							使用new[]分配的内存必须使用delete[]进行释放：
							<code>delete [] ptr;</code>
							new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。</p>
							<p>至于malloc，它并不知道你在这块内存上要放的是数组还是啥别的东西，反正它只给你一块原始的内存，再给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小：
							<code>int * ptr = (int *) malloc( sizeof(int) * 10 );//分配一个10个int元素的数组</code></p>
						</div>
						<div id="text_07">
							<h3>7.是否可以相互调用</h3>
							<p>operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。</p>
							<p>下面是编写operator new /operator delete 的一种简单方式，其他版本也与之类似：</p>
							<pre><code class="language-c++">void * operator new (sieze_t size)<br/>{<br/><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>if(void * mem = malloc(size)<br/><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>return mem;<br/><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>else<br/><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>throw bad_alloc();<br/>}<br/>void operator delete(void *mem) noexcept<br/>{<br/><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>free(mem);<br/>}</code></pre>
						</div>
						<div id="text_08">
						<h3>8.是否可以被重载</h3>
							<p>opeartor new /operator delete可以被重载。</p>
							<p>标准库是定义了operator new函数和operator delete函数的8个重载版本：</p>
							<pre><code class="language-c++">//这些版本可能抛出异常<br/>void * operator new(size_t);<br/>void * operator new[](size_t);<br/>void * operator delete (void * )noexcept;<br/>void * operator delete[](void *0）noexcept;<br/>//这些版本承诺不抛出异常<br/>void * operator new(size_t ,nothrow_t&amp;) noexcept;<br/>void * operator new[](size_t, nothrow_t&amp; );<br/>void * operator delete (void *,nothrow_t&amp; )noexcept;<br/>void * operator delete[](void *0,nothrow_t&amp; ）noexcept;</code></pre>
							<p>我们可以自定义上面函数版本中的任意一个，前提是自定义版本必须位于全局作用域或者类作用域中。太细节的东西不在这里讲述，总之，我们知道我们有足够的自由去重载operator new /operator delete ,以决定我们的new与delete如何为对象分配内存，如何回收对象。</p>
							<p>而malloc/free并不允许重载。</p>
						</div>
						<div id="text_09">
							<h3>9.能够直观地重新分配内存</h3>
							<p>使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。</p>
							<p>new没有这样直观的配套设施来扩充内存。</p>
						</div>
						<div id="text_10">
							<h3>10.客户处理内存分配不足</h3>
							<p>在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler。new_handler是一个指针类型：</p>
							<pre><code class="language-c++">namespace std<br/>{<br/><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>typedef void (*new_handler)();<br/>}</code></pre>
							<p>指向了一个没有参数没有返回值的函数,即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_handler，这是一个声明于的一个标准库函数:</p>
							<pre><code class="language-c++">namespace std<br/>{<br/><span style="mso-tab-count:1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>new_handler set_new_handler(new_handler p ) throw();<br/>}</code></pre>
							<p>set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。
							对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。</p>
						</div>
					</div>
					<div class="tag">
						<span>Tag : </span>
						<ul>
							<li><a href="#">C++</a></li>
							<li><a href="#">new</a></li>
							<li><a href="#">delete</a></li>
							<li><a href="#">malloc</a></li>
							<li><a href="#">free</a></li>
						</ul>
					</div>
				</article>	
			</div>
		</div>
		<div class="col-1-4">
			<div class="context">
				<div id="sidebar" class="wrap-col">
					<div class="widget">
						<div class="wid-header"><h2>目录</h2></div>
						<div class="context_items">
					        <a href="#overriew">概述</a>
					            <br/>
					        <a href="#text_01">1.申请的内存所在位置</a>
					            <br/>
					        <a href="#text_02">2.返回类型安全性</a>
					            <br/>
					        <a href="#text_03">3.内存分配失败时的返回值</a>
					            <br/>
					        <a href="#text_04">4.是否指定内存大小</a>
					            <br/>
					        <a href="#text_05">5.是否调用构造/析构函数</a>
					            <br/>
					        <a href="#text_06">6.对数组的处理</a>
					            <br/>
					        <a href="#text_07">7.是否可以相互调用</a>
					            <br/>
					        <a href="#text_08">8.是否可以被重载</a>
					            <br/>
					        <a href="#text_09">9.能够直观地重新分配内存</a>
					            <br/>
					        <a href="#text_10">10.客户处理内存分配不足</a>
					            <br/>
	    				</div>
					</div>
				</div>
			</div>
		</div>
	</div>
</section>
<!--------------Footer---------------->
<footer>
	<div class="wrap-footer zerogrid">
		<div class="row">
			<div class="col-full">
				<div class="wrap-col" style="color:#4D4D4D">
					<h1>XINWUYA</h1>
					<p>xinwuya_scu@163.com | @ 2019</p>
				</div>
			</div>
		</div>
	</div>
</footer>

</div>
<script type="text/javascript" src="../js/jquery.min.js"></script>
<script type="text/javascript" src="../js/navigation.js"></script>
<script type="text/javascript">
</body></html>