# C预处理器、作用域、static以及内存管理

## 1.C预处理器

1）C语言的预处理主要有三个方面的内容：
- 宏定义与宏替换
- 文件包含
- 条件编译

2）由于预处理是在编译之前的处理，而编译工作的任务之一就是语法检查，故预处理是不做语法检查的。且宏定义不分配内存，变量定义才会分配内存。

3）为了避免宏替换时发生错误，宏定义中宏参数应加上括号。宏定义可以嵌套使用。

4）宏替换的本质很简单——文本替换。
关于宏定义与宏替换请注意以下几点：
- 宏名一般用大写，宏名和参数的括号间不能有空格，宏定义末尾不加分号；
- 宏替换只作替换，不做语法检查，不做计算，不做表达式求解；
- 宏替换在编译前进行，不分配内存，函数调用在编译后程序运行时进行，并且分配内存；
- 函数只有一个返回值，利用宏则可以设法得到多个值；
- 宏替换使源程序变长，函数调用不会；
- 宏替换不占运行时间，只占编译时间，函数调用占运行时间（分配内存、保留现场、值传递、返回值）
注：应尽量少用宏替换，在C++中，宏替换实现的符号常量功能由const、enum代替，带参数阿宏替换可由模板内联函数代替。

5）如果头文件名包含在<>中，则为标准头文件，编译器将会在预定义的位置集合中查找该头文件，这些预定义的位置可以通过设置查找路径环境或者通过命令行选项来修改；如果头文件名包含在""中，则为非系统文件，通常在源文件所在的路径查找。

6）条件编译控制语句：
    `#if/ifdef/ifndef`
    `#elif`
    `#else`
    `#endif`

7）在同一个文件中，当局部变量屏蔽了全局变量，而又想要使用全局变量时，有两种方法：
1. 使用作用域操作符“::”;
2. 使用extern;

## 2.static的作用
1）**隐藏**。当我们同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性，而如果加了static，就会对其他源文件隐藏。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。
注：static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏，而对于变量，static还有下面两个作用。
2）**默认初始化为0，包括未初始化的全局静态变量与局部静态变量**（未初始化的全局变量与未初始化的静态变量是存储在同一块区域BSS段，BSS段中内存的所有字节默认值都是0x00；初始化的静态变量存储在data段中）。
3）**保持局部变量内容的持久**。函数内的局部变量只有当函数被调用时存在，退出函数时就消失，但静态局部变量虽然在函数内定义，但静态局部变量始终存在着，它的生存期为整个源程序，但**需注意的是它的作用域仍与局部变量相同，即只能在定义该变量的函数内使用该变量，退出函数时，尽管该变量依然存在，但不能使用**。

## 3.类中static：
表示属于一个类而不是属于此类的任何特定对象的变量和函数，static成员可以是函数或数据，都独立于类类型的对象而存在。

- **静态数据成员**：
    1）static数据成员独立于该类的任意对象而存在；每个static数据成员的值为该类的所有实例共享。
    2）静态数据成员和普通数据成员一样遵从public，protected，private访问规则；
    3）静态数据成员在存储在全局（静态）存储区。**静态数据成员定义时要分配空间，所以不能在类声明中定义**。static数据成员必须在类定义体的外部定义，通常在外部定义时才初始化，即在类定义体内对静态变量赋初值是错误的（基本整型const static数据尘缘可以在类的定义体内进行初始化，在类定义体中初始化时，该数据成员仍必须在类的定义体外进行定义，只不过定义时，不再需要初始化）。
	4）类中数据成员的布局情况是：
    1. 非静态成员在类对象中的排列顺序和声明顺序一致，任何在其中间声明的静态成员都不会被放进对象布局中；
    2. 静态成员存放在程序的全局（静态）存储中，和个别类对象无关；
    3. C++中，在同一个访问块private、public、protected等区段中，成员的排列只需要符合较晚出现的成员在类对象中有较高的地址即可，并不一定要连续排列。什么东西可能会介于被声明的members之间呢？比如members的边界调整时需要填充的一些字节等。

- **静态成员函数**：
    1）静态成员函数可以访问静态数据成员和静态成员函数。静态成员函数不能访问非静态成员函数和非静态数据成员，非静态成员函数可以任意地访问静态成员函数和静态数据成员。
    2）由于没有this指针的额外开销，因此静态成员函数与类的非静态成员函数相比速度上会有少许的增长。
    3）static成员不是任何对象的组成部分，所以static成员函数不能被声明为const。将成员函数声明为const就是承诺不会修改该函数所属的对象，而static成员函数不属于任何对象。
    4）static成员函数不能声明为虚函数、volatile。

- 使用static成员变量而不是全局变量有三个优点：
    1）static成员的名字是在类的作用域中，因此可以避免与其他类的成员或全局对象名字冲突。
    2）可以实施封装，static成员可以是私有成员，而全局对象不可以。
    3）通过阅读程序容易看出static成员是特定类关联的。这种可见性可清晰地显示程序员的意图。

## 4.const
1.**const**：作为一个限定符，将一个对象转换成一个常量。**常量在定义后就不能被修改，所以定义时必须初始化。**

2.在全局作用域中定义非const变量时，它在整个程序中都可以访问；而在全局作用域中定义const变量是定义该对象的文件的**局部变量**。此变量只存在于那个文件中，不能被其他文件访问。通过指定const变更为extern，就可以在整个程序中访问const对象。

## 5.const在C/C++中的区别
1）C中const指一个不能被改变的普通变量。C编译器不能把const视为一个编译期间的常量，如使用const变量声明一个数组在C中是错误的，而在C++中该写法是正确的。
    `const int bufsize=100;`
   ` int buf[bufsize];`
2）C默认const是外部连接的,C++默认const是内部连接的，如果要改成外部连接。必须使用extern。
    `const int size;//C中正确,C++中编译报错必须初始化`
    `extern const int size;//C++中通过`
注：在C语言中使用限定符const不是很有用，C迫使程序员在预处理器里使用#define。

## 6.C++中应该用const取代#define
1）**const常量有数据类型，而宏常量没有数据类型**。编译器可以对前者进行类型安全检查。而对后者只进行字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误；
2）使用常量可能比使用#define导致产生**更小的目标代码**，这是因为预处理器“盲目地将宏名长替换为其代替的值”可能导致目标代码出现大量的备份，但常量就不会出现这种情况。
3）同时const还可以执行**常量折叠**（常量折叠是在编译时间简单化常量表达的一个过程，简单来说就是将常量表达式计算求值，并用求得的值来替换表达式，放入常量表），也就是说，编译器在编译时可以通过必要的计算把一个复杂的常量表达式缩减成简单的。

## 7.指向const的指针和const指针
- 指向const的指针：

        const double *cptr; //等价于double const * cptr;

	如果指针指向const对象，则不允许用指针来改变其所指的const值，C++强制要求指向const对象的指针也必须具有const特性。这里不需要初始化，因为cptr可以指向任何东西，但所指的东西不能被改变。

- const指针：
    是指针本身成为一个const指针，必须把const标明的部分放在*的右边。

    	double* const cptr=&d;
    	double d=1.0;

    因为指针本身是const指针，编译器要求给它一个初始化值，这个值在指针寿命期间不变。然而要改变它所指向的值是可以的，可以写`* cptr = 2.0;`。

注：将const指针变为指向一个const对象：

    double d = 1.0;
    const double * const x=&d;//等价于double const * const x=&d;

现在指针和对象都不能改变。

    double* ptr=&value;//ptr是一个指向double类型的指针，ptr的值可以改变，ptr所指向的value的值也可以改变；
    const double* ptr=&value;//ptr是一个指向const double类型的指针，ptr的值可以改变，不能通过ptr改变value的值；
    double* const ptr=&value;//ptr是一个指向double类型的const指针，ptr的值不可以改变，可以通过ptr改变value的值；
    const double* const ptr=&value;//ptr是一个指向const double类型的const指针，ptr的值不可以改变，也不能通过ptr改变value的值。

## 8.const成员函数不能修改调用该函数的对象（mutable成员除外）

    class base{
        void func() const;
    };

func函数声明末尾的const改变了隐含的this形参的类型，使this形参指向的对象为const类型（this本身类型为base*const，函数声明末尾加上const后，tihs的类型为const base*const，即this指向的对象也为const）。
const实施于成员函数的目的，是为了确保该成员函数可作用于const对象身上。const对象、指向const对象的指针或引用只能调用其const成员函数，如果尝试用它们来调用非const成员函数，则是错误的。而非const对象可调用非const成员函数与const成员函数。
注：如果两个成员函数只是常量性不同，可以被重载。const只能作用于成员函数，不能作用于全局函数。

## 9.C++中static、const以及static const成员变量的初始化。

1）static静态成员变量不能在类内初始化，在雷曼内部只是声明，定义必须在类定义体外部，通常在类的实现文件中初始化，static关键字只能用于类定义体内部的声明中，定义时不能标示为static。

    class Test{
        static int A;
    };
    int Test::A = 1;

2）const现在可以在类定义处初始化。const数据成员只在某个对象生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。

3）要想建立在整个类中都恒定的常量，应该用类中的**枚举常量**来实现，或者s**tatic const**。

## 10.内存管理

1）**堆和栈的区别**：

- 栈区（stack），由编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈，速度较快。
- 堆区（heap），一般由程序员分配内存释放，若程序员不释放，程序结束时由操作系统回收。分配方式类似于链表。一般速度较慢，而且容易产生内存碎片，不过用起来方便。

2）每个程序在执行时都占用一块可用的内存空间，用于存放动态分配的对象，此内存空间成为程序的自由存储区或堆。

3）通常，动态创建对象如果不提供显式初始化，那么对于类类型的对象，用该类的默认构造函数初始化；而内置类型的对象则无初始化。

    string *ps=new string;//调用默认构造函数初始化
    int *pi=new int;//无初始化

显式初始化：

    string *ps=new string();//调用默认构造函数初始化
    int *pi=new int();//pi指向一个初始化为0的int值

因此对于提供了默认构造函数的类类型，没有必要对其对象进行显式初始化；而对于内置类型或没有定义默认构造函数的类型，采用不同的初始化方式则有显著的区别。

4）动态创建的对象用完后，程序员必须显式地将该对象占用的内存释放给自由存储区。在回收用new分配的单个对象的内存空间时用delete，回收用new[]分配的一组对象的内存空间时用delete[]。

## 11.C++允许动态创建const对象。
`const int *pci=new const int(1024);`
动态创建的const对象必须在创建时初始化，并且一经初始化，其值就不能再修改。
注：删除const对象仍使用：`delete pci;`。

## 12.malloc/free与new/delete的区别：
- 相同点：都可用于申请动态内存和释放内存。
- 不同点：
1）malloc/free是C/C++语言的标准库函数，new/delete是C++的运算符；
2）new自动计算需要分配的空间，而malloc需要手工计算字节数；
3）new是类型安全的，而malloc不是（因为new内置了sizeof、类型转换和类型安全检查功能）；
`int* p=new float[2];//编译时指出错误`
`int* p=(int*)malloc(2*sizeof(double));//编译时无法指出错误`
4）new调用operator new分配足够的空间，并调用相关对象的构造函数，而malloc不能调用构造函数；delete将调用该实例的析构函数，然后调用类的operator delete以释放该实例占用的空间，而free不能调用析构函数；
5）malloc/free需要库文件支持，new/delete则不需要。
注：如果对象有多个构造函数，那么new的语句也可以有多种形式；而如果new创建对象数据，那么只能使用对象的无参数构造函数。

## 13.用宏求结构体的内存偏移地址：

    #define OFFSET(type, field) ((int)&(((type*)0)->field))
    struct S{
        int a;
        char c;
        int b;
    };
    cout << OFFSET(S,c);//输出4

## 14.生命周期和作用域
- 生命周期：是一个变量存在的周期。
- 作用域：一个变量可以被引用的范围，如：全局作用域、文件作用域、局部作用域。可以用{}、static修饰符等来指定一个变量的作用域和生命周期。

|     Name     |   作用域   |           生命周期           |                           引用方法                           | 内存分布           | 注                                                           |
| :----------: | :--------: | :--------------------------: | :----------------------------------------------------------: | ------------------ | ------------------------------------------------------------ |
|   全局变量   | 全局作用域 |      程序运行期一直存在      | 其他文件中要使用必须用extern关键字声明要引用的全局变量或通过包含头文件的方式 | 全局（静态）存储区 | 如果两个文件都定义了相同名字的全局变量，则连接出错：变量重定义 |
| 全局静态变量 | 文件作用域 |      程序运行期一直存在      |                  static关键字，const关键字                   | 全局（静态）存储区 | 只要文件不互相包含，在两个不同的文件中是可以定义完全相同的两个全局静态变量的，他们是两个完全不同的变量 |
| 静态局部变量 | 局部作用域 |      程序运行期一直存在      |                   局部作用域中用static定义                   | 全局（静态）存储区 | 只被初始化一次，多线程须加锁保护                             |
|   局部变量   | 局部作用域 | 程序运行出局部作用域即被销毁 |        局部作用域用auto指示符定义，也可省略auto指示符        | 栈区               |                                                              |


## 15.如何减少频繁分配内存（new/malloc）造成的内存碎片：
使用内存池，这是一种分配方式。通常直接使用new、malloc等申请内存，这样做的缺点在于：由于所申请的内存块大小不定，当频繁使用时会造成大量的内存碎片进而降低性能。内存池则是在真正使用内存之前，先申请一定数量的、大小相等（一般情况下）的内存块留作备用。当有新的内存需求时，就从内存池中分出一部分内存块，若内存块不够则再继续申请新的内存。这样做的一个显著优点就是尽量避免了内存碎片，使得内存分配效率得到提升。

## 16.缓冲区溢出：
指向缓冲区内填充数据位数超过了缓冲区本身的容量限制，导致溢出的数据覆盖在合法数据上的情况。理想的情况是程序检查数据长度并不允许超过缓冲区长度的字符，但是绝大多数程序都会假设数据长度总是与所分配的内存空间相匹配，这就为缓冲区溢出埋下隐患。造成缓冲区溢出的原因是程序中没有仔细检查用户输入的参数.

    void func(char* str)
    {
        char buff[16];
        strcpy(buff,str);
    }//只要str的长度超过16，就会造成buff溢出，程序运行出错