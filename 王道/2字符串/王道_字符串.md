# 字符串

## 1.子串与子序列：

- 子串：串中任意个连续的字符组成的子序列，空串是任意串的子串；
- 子序列：不要求字符连续但顺序与其所在主串中相一致，如“abcd”和“ad”最长的公共子序列为“ad”。

## 2.[字符串处理函数](./字符串处理函数.md)

<table border=0 cellpadding=0 cellspacing=0 width=1390 style='border-collapse:
 collapse;table-layout:fixed;width:1043pt'>
 <col width=117 style='mso-width-source:userset;mso-width-alt:3744;width:88pt'>
 <col width=1273 style='mso-width-source:userset;mso-width-alt:40736;
 width:955pt'>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl642128 width=117 style='height:14.25pt;width:88pt'>函数</td>
  <td class=xl642128 width=1273 style='border-left:none;width:955pt'>说明</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl632128 style='height:14.25pt;border-top:none'>strlen(s)</td>
  <td class=xl632128 style='border-top:none;border-left:none'>返回s的长度，不包括字符串结束符
  null</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl632128 style='height:14.25pt;border-top:none'>strcmp(s1,
  s2)</td>
  <td class=xl632128 style='border-top:none;border-left:none'>比较两个字符串s1和s2是否相同。若s1与s2相等，返回0；若s1大于s2，返回正数；若s1小于s2，则返回负数【两个字符串自左向右逐个字符按ASCII码相比较，直至出现不同的字符或遇'\0'为止】</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl632128 style='height:14.25pt;border-top:none'>strcat(s1,
  s2)</td>
  <td class=xl632128 style='border-top:none;border-left:none'>将s2连接到s1后，并返回s1【覆盖s1结尾处的'\0'并在新的结尾添加'\0'】</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl632128 style='height:14.25pt;border-top:none'>strcpy(s1,s2)</td>
  <td class=xl632128 style='border-top:none;border-left:none'>将s2复制给s1，并返回s1【把从s2地址开始且含有null结束符的字符串复制到以s1开始的地址空间】</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl632128 style='height:14.25pt;border-top:none'>strncat(s1,s2,n)</td>
  <td class=xl632128 style='border-top:none;border-left:none'>将s2的前n个字符连接到s1后面，并返回s1</td>
 </tr>
 <tr height=19 style='height:14.25pt'>
  <td height=19 class=xl632128 style='height:14.25pt;border-top:none'>strncpy(s1,s2,n)</td>
  <td class=xl632128 style='border-top:none;border-left:none'>将s2的前n个字符复制给s1，并返回s1</td>
 </tr>
 <![if supportMisalignedColumns]>
 <tr height=0 style='display:none'>
  <td width=117 style='width:88pt'></td>
  <td width=1273 style='width:955pt'></td>
 </tr>
 <![endif]>
</table>


注：这些函数假设他们所修改的字符串具有足够大的空间接收本函数新生成的字符，程序员必须确保目标字符串足够大。

## 3.memcpy()：
从源src所指的内存地址的起始位置开始，拷贝n个字节到目标dest所指的内存地址的起始位置，返回指向dest的指针。

`void *memcpy(void *dest, const void *src, size_t n);`

strcpy与memcpy的区别：

- 复制的内容不同。strcpy只用于字符串复制，除了复制字符串内容，还会复制字符串的结束符；memcpy可以复制任意内容，例如字符数组、整型、结构体、类等，对于需要复制的内容没有限制，用途更广。
- 复制的方法不同。strcpy不需要指定长度，遇到被复制字符的'\0'时结束，容易溢出；memcpy对需要复制的内容没有限制，因此用途更广。
- 用途不同。strcpy通常用于复制字符串；memcpy则用于复制其他类型数据。

## 4.memset()：
将s中的前n个字节用ch替换并返回s，作用是在一段内存块中填充某个给定的值，是对较大结构体或数组进行清零操作的一种最快方法。

`void *memset(void *s, int ch, size_t n);`

## 5.查找字串

如主串A="ababcabcacbab"，子串为B="abcac"。

- 方法一：暴力求解

BF算法：时间复杂度为O((m-n+1)*n)

    const char* findSubstring_BF(const char *str, const char *substr)
    {
    	_ASSERT(str != nullptr && substr != nullptr);
    	int m = strlen(str);
    	int n = strlen(substr);
    	if (m < n)
    		return nullptr;
    
    	for(int i =0; i < m - n; ++i)
    	{
    		for (int k = 0; k < n; ++k)
    			if (str[i + k] != substr[k])
    				break;
    		if (i == n)
    			return str+i;
    	}
    
    	return nullptr;
    }

显式回退

    const char* findSubstring_EF(const char *str, const char *substr)
    {
    	_ASSERT(str != nullptr && substr != nullptr);
    
    	int m = strlen(str);
    	int n = strlen(substr);
    	int i = 0, k = 0;
    	for(;i < m && k < n; i++)
    	{
    		if (str[i] == substr[k]) k++;
    		else
    		{
    			i -= k;//显式回退
    			k = 0;
    		}
    	}
    	if (k == n) return str + i - n;
    	else return nullptr;
    }

- 方法二：KMP算法：时间复杂度为O(m+n)


## 6.字符串移位包含问题：

判断s2是否能被s1做循环位移得到的字符串包含，可以转化为判断s2是否被s1s1包含，在写代码时，则可以通过取模操作。

    bool find_CyclicDisplacement(const char* str, const char* substr)
    {
    	_ASSERT(str != nullptr && substr != nullptr);
    	int m = strlen(str);
    	int n = strlen(substr);
    	if (m < n) return false;
    
    	int p;
    	for(int i =0; i < m; ++i)
    	{
    		p = i;
    		for(int k = 0; k < n; ++k)
    		{
    			if (str[p++%m] != substr[k]) break;
    		}
    		if (p - i == n)
    			return true;
    	}
    	return false;
    }


## 7.字符串转换为数字

    int convertStrToInt(const char* str)
    {
    	long long result = 0;
    
    	if(str != nullptr)
    	{
    		const char* tempStr = str;
    		bool isNegative = false;
    		if (*tempStr == '+')
    			tempStr++;
    		else if(*tempStr == '-')
    		{
    			tempStr++;
    			isNegative = true;
    		}
    		while(*tempStr != '\0')
    		{
    			if(*tempStr >= '0' && *tempStr <= '9')
    			{
    				result = result * 10 + (*tempStr - '0');
    				if(result > std::numeric_limits<int>::max())
    				{
    					result = 0;
    					break;
    				}
    				tempStr++;
    			}
    			else
    			{
    				std::cout << "Contains non-number members." << std::endl;
    				result = 0;
    				break;
    			}
    		}
    		if(*tempStr == '\0')
    		{
    			if (isNegative)
    				result = -result;
    		}
    	}
    	return result;
    }


## 8.判断字符串中所有字符是否都不相同：时间复杂度为O(n)，n为字符串长度

    bool char_set[256];
    int isUniqueCharString(const char* str)
    {
    	_ASSERT(str != nullptr);
    	int len = strlen(str);
    	for(int i = 0; i < len; ++i)
    	{
    		if(char_set[str[i]]) return 0;
    		char_set[str[i]] = true;
    	}
    	return 1;
    }



## 9.`int snprintf(char * s, size_t n, const char * format, ...);`

其功能为将可变个参数(...)按照format格式转化为字符串，然后将其复制到str中。

- 如果格式化后的字符串长度小于size，则将此字符串全部复制到str中，并给其后添加一个'\0'；
- 如果格式化后的字符串长度大于size，则只将其中的size-1个字符复制到str中，并给其后添加一个'\0'。

例如：`int cx = snprintf ( buffer, 100, "The half of %d is %d", 60, 60/2 );`

其结果：`The half of 60 is 30`