# 结构体、共用体与枚举

## 1.结构体

- 结构体相比于数组，有以下两点不同：
    - 结构体可以在一个结构中声明不同的数据类型；
    - 相同的结构体变量是可以相互赋值的。
- class的成员访问权限默认为private，而struct成员的访问权限默认为public。
- struct不能定义无参的构造函数。

## 2.结构体定义：
定义时只说明该类型的组成情况，并没有分配空间，只有当定义属于结构体类型的变量时，系统才会分配空间给该变量。

- 结构体类型定义中不允许对结构体本身的递归定义，但可以使用指针指向本类型：
```c++
struct Person{
    struct Person* pPerson;//指向本类型的指针
}
```
- 结构体定义中可以包含另外的结构体，即结构体是可以嵌套的；

- 结构体变量可以在定义时进行初始化赋值。

## 3.位字段

c/c++允许指定占用特定位数的结构成员，字段的类型应为整型或者枚举，接冒号，接数字。该数字指定了使用的位数，且可以使用没有名称的字段来提供间距，每个成员都被称为位字段。可以达到压缩数据的目的。

```c++
struct Reg{
	unsigned int SN：4；
	unsigned int :4;
	bool good:4;
}
```

注：在进行赋值时，不应该超过该位域的允许范围，超过时仅将值的低位赋值给位域。

## 4.共用体union

共用体中所有类型的变量共享同一段内存，达到节省空间的目的。

与结构体的区别：

- 在任何同一时刻，共用体中只存放了一个被选中的成员；而结构体的所有成员都存在。
- 对于共用体的不同成员赋值，将会对其他成员重写，原来成员的值就不存在了；而对于结构体的不同成员赋值是互不影响的。
- 共用体中各成员共享一段内存空间，一个共用体的总长度等于个成员中最长的长度；结构体各成员有各自的内存空间，一个结构体变量的总长度是各成员长度之和（空结构除外，同时不考虑边界调整）。

注：结构体占用内存可能超过各成员内存量总和。

union和struct都是从低地址开始存放。

共用体的用途之一是当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。

## 5.大端存储格式、小端存储格式

存储32位宽0x12345678

- 大端存储格式：字数据的高字节存放在低地址中，而字数据的低字节存放在高地址中；

  | 内存地址 | 0x4000 | 0x4001 | 0x4002 | 0x4003 |
  | :------: | :----: | :----: | :----: | :----: |
  | 存放内容 |  0x12  |  0x34  |  0x56  |  0x78  |


- 小端存储格式：字数据的低字节存放在低地址中，而字数据的高字节存放在高地址中。

  | 内存地址 | 0x4000 | 0x4001 | 0x4002 | 0x4003 |
  | :------: | :----: | :----: | :----: | :----: |
  | 存放内容 |  0x78  |  0x56  |  0x34  |  0x12  |

  


常用的x86架构是小端模式，而Sun的SPACRC采用大端模式。

判断大小端的方式：

```c++
#define BIG_ENDIAN 0
#define LITTLE_ENDIAN 1

int TestByteOrder()
{
	short int word=0x0001;
	char* byte=(char*)&word;
	return (byte[0] ? LITTLE_ENDIAN: BIG_ENDIAN);
}
```

## 6.枚举

enum 枚举类型名{枚举常量1[=整型常数], 枚举常量2[=整型常数],  ...}[变量名列表]

注：如果不给枚举常量赋初值，编译器会为每个枚举常量赋一个不同的整型值，第一个为0，第二个为1等。当枚举表中某个常量赋值后，其后的成员则按依次加1的规则确定其值。

## 7.sizeof()

注：`sizeof`的计算发生在编译时刻，所以可以被当作常量表达式使用，且会忽略其括号内的各种运算，如`sizeof(a++) `中的`++`不执行。

- `sizeof`用于**变量**或**对象**时可以不使用括号括住，但在用于**数据类型**时必须用括号括住（实际上`sizeof`计算对象的大小也是转换成对象类型的计算，同种类型的不同对象其`sizeof`值都是一致的）。
- `sizeof`也可以对一个**函数调用**求值，其结果是函数返回类型的大小，函数并不会被调用（返回类型为void的不能计算） 。
- C99标准规定，**函数名称**、不能确定类型的表达式以及位域成员不能计算`sizeof`值，即以下写法均为错误：

    1)

    ```c++
    int foo() {return 1;}
    sizeof(foo);//错误
    ```

    2) 

    ```c++
    void foo() {}
    sizeof(foo());//错误
    ```

    3) 

    ```c++
    struct S{
    unsigned int f1 : 1;
    unsigned int f2 : 5;
    }s;
    sizeof(s.f1);//错误
    ```

## 8.sizeof的结果：

返回类型为`size_t`，被定义为`unsigned int`类型。

`sizeof(char)`:1

`sizeof(short)`:2

`sizeof(int/long/float/指针)`:4

`sizeof(double)`:8

这些简单的内置数据类型和系统相关，在不同的系统下取值可能不同。

注：`sizeof("\0")`=2。

- 32位机器系统下，指针变量的`sizeof`为4，64位机器系统下，指针变量的`sizeof`为8。
- 所有引用的`sizeof`等同于被引用对象的`sizeof`。
- C/C++中一个汉字占两个字节，且字符串末尾有1个空字符。（Linux中如使用UTF-8，则每个汉字占3个字节）
- 对于数组，sizeof可直接计算数组大小。

    ```c++
    int a[10];//sizeof(a):40
    char b[]="hello";//sizeof(b):6
    int* c = new int[50];//sizeof(c):4
    ```

- 数组做形参时，数组名称当作指针使用。

    ```c++
    void fun1(char a1[3])
    {
    	int c1=sizeof(a1);//c1=4
    }
    void fun2(char a2[])
    {
    	int c2=sizeof(a2);//c2=4
    }
    ```

- 数组为高维数组时，占用空间=各维度之积* 数组所存放元素占用空间。

    32位机器上，`int ** a[3][4]`，该数组占空间大小为3 * 4 * 4=48。

## 9.struct的空间计算：

总体上遵循两个原则：

1）整体空间是占用空间最大的成员（的类型）所占字节数的整数倍，但在32位Linux+gcc环境下，若最大成员类型所占字节数超过4，如double是8，则整体空间是4的倍数即可；

2）数据对齐原则——内存按结构体成员的先后顺序排列，当排到该成员变量时，其前面已摆放的空间大小必须是该成员类型大小的整数倍，如果不够则补齐，依次向后类推，但在Linux+gcc环境下，若某成员类型所占字节数超过4，如double是8，则前面已摆放的空间大小是4的整数倍即可，不够则对齐。

```c++
struct s1{
	char a;//8（补齐至8的倍数）
	double b;//8
	int  c;//4
	char d;//4（补齐至8的倍数）
};//sizeof(s1):24
struct s2{
	char a;//1
	char b;//3(补齐至4的倍数)
	int  c;//4
	double d;//8
};//sizeof(s2):16

//若在Linux+gcc环境下，应分别为：20 16

struct s3{
	char c;
	int  i;
};//sizeof(s3):8
struct s4{
	char c1;
	s3   s;
	char c2;
};//sizeof(s4):16
```

注：

- 当**结构体中含有结构体**时，我们称s3为子结构体，s4为父结构体，此时的两项原则为：

    1）整体空间是子结构体与父结构体中占用空间最大的成员（的类型）所占字节数的整数倍；但在Linux+gcc环境下，若最大成员类型所占字节数超过4，如double是8，则整体空间是4的倍数即可；

    2）数据对齐原则——父结构体内存按结构体成员的先后顺序排列，当排到子结构体成员时，其前面已摆放的空间大小必须是**该子结构体成员中最大类型大小**的整数倍，如果不够则补齐，依次向后类推。在Linux+gcc环境下，若某成员类型所占字节数超过4，如double是8，则前面已摆放的空间大小是4的整数倍即可，不够则对齐。

- 当**结构体中含有数组**时，计算sizeof并未将数组当成一个整体。

    ```c++
    struct s5{
    	char b;
    	char a[8];
    };//sizeof(s5):9
    ```

- 当结构体中含有位域时，位域成员是不能单独计算sizeof值，而包含位域的结构体可以。使用位域的主要目的是压缩存储，大致规则为：

    1）如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止；

    2）如果相邻位域字段的类型相同，且其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍；

    3）如果相邻的位域字段类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++与gcc采取压缩方式；

    4）**如果位域字段之间穿插着非位域字段**，则不进行压缩；

    5）整个结构体的总大小为最宽基本类型成员大小的整数倍。

    （VS2010环境下int a:4，如果后面不是位域，则占用4个字节，Dev-C++/Linux+gcc环境下，如果后面不是位域，仅占1个字节；在压缩情况下，一个字节可以容纳两个char）

    ```c++
    struct b1{
    	char f1:3;
    	char f2:4;
    	char f3:5;
    };//sizeof(b1):2
    ```

- 当存在“`#pragma pack`”时，

    1）使用伪指令`#pragma pack(n)`，编译器将按照n个字节对齐；

    2）使用伪指令`#pragma pack()`，取消自定义字节对齐方式。

    注：n取值为1，2，4，8，16等，默认是8，如果这个值比结构体成员的`sizeof`值小，那么该成员的偏移量应以此值为准，即结构体成员的偏移量应取二者的最小值。同时结构体的大小也是所有`offset(item)`中最大值的整数倍。

- 当结构体为空时，`sizeof`值为1。

## 10.union的空间计算

结构体在内存组织上是顺序式的，联合体则是重叠式的，因此联合体的`sizeof`值为各成员`sizeof`的最大值。

```c++
struct s1{
	double b;
};
union U{
	int i;
	char c;
	s1 s;
};//sizeof(U):8

union U2{
	char c[9];
	int vbh[2];
};//sizeof(U2):12
//要考虑对齐！
```

## 11.枚举的空间计算

`enum`只定义了一个常量集合，里面没有“元素”，而枚举类型是当作`int`类型来存储的，故枚举类型的`sizeof`值都为4。

```c++
struct s1{
	enum e1{a=0,b,c,d,e,f};
	enum e2{x,y,z};
};//sizeof(s1):1
struct s2{
	enum e1{a=0,b,c,d,e,f}e_1;
	enum e2{x,y,z}e_2;
};//sizeof(s2):8
```

如果结构体中仅存在枚举声明，该结构体为空结构体，其`sizeof`值为1；如果结构体存在枚举变量，其内每个`enum`的`sizeof`值为4。